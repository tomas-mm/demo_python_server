"""
define singleton memory objects shared by the different processes
(works as an in-memory database)
"""
import time
import uuid
import logging

import binascii
import multiprocessing
import threading

from users import Users, SESSION_KEY_EXPIRATION

logger = logging.getLogger('storage')

NUM_TOP_SCORES = 15


class UserToken(object):
    """
    Small class to avoid a new module, keeping methods grouped
    
    hash size
    N possible hash values, k possible users (2**31)
    Assuming random token assignation:
    probability of collision ~= 1 - e**((-k*(k-1)/2/N))
    simpler approximation -> probability of collision = k**2/(2*N)
    prob_col = lambda N, k: 1 - math.e ** ((-k * (k - 1) / 2 / N))
    prob_col(2**64.0, 2**31.0) = 0.12
    prob_col(2**128.0, 2**31.0) ~= 0
    
    We could compose a token of 2 parts: a unique user id (uint 128 bits) and an Epoch time stamp (uint 32 bits)
    but using uuid1 to get a 128 bits token using a user_id and a timestamp is valid and easier

    The user id is provided at login and it's already unique
    """

    @staticmethod
    def get(user_id):
        """
        Generate a new 128 bits token (encoded in base64) for a given user_id (int)
        The user_id is used as node of the uuid
        """
        token = uuid.uuid1(int(user_id))
        bin_token_str = binascii.unhexlify(token.hex)
        b64 = binascii.b2a_base64(bin_token_str)
        # using the URL- and filesystem-safe alphabet, which substitutes - instead of + and _ instead of / i
        return b64.replace('+', '-').replace('/', '_')

    @staticmethod
    def get_posixtime(uuid1):
        """
        Convert the uuid1 timestamp to a standard posix timestamp
        The uuid timestamp is 60 bits, the number of 100 nanosecond increments since Oct. 15, 1582
        """
        assert uuid1.version == 1, ValueError('only applies to type 1')
        t = uuid1.time
        t = t - 0x01b21dd213814000
        t = t / 1e7
        return t

    @staticmethod
    def validate(b64_token, timeout):
        """
        Returns the user_id if the token is valid (correct format and not expired) None otherwise
        """
        try:
            b64_token = b64_token.replace('-', '+').replace('_', '/')
            hex_token_str = binascii.hexlify(binascii.a2b_base64(b64_token))
            token = uuid.UUID(hex=hex_token_str)
            p_time = UserToken.get_posixtime(token)
            now = time.time()
            if (now - timeout) < p_time <= now:
                return token.node
        except:
            pass

        return None


class UsersStored(Users):
    """
    Manage shared users object
    When created, this will spawn a 'manager' process if forked = True
    The user_id and the time stamp are embedded in the token we would not even need to store the user,
    but we can store it to validate that the token is not self-generated by the client (encryption would also work)
    and to store more user related data in the future.
    """
    def __init__(self, forked=True):
        """
        :param forked: boolean, if True a sync manager server is created to share data
            otherwise the data will be shared only between threads.
        """
        if forked:
            self.manager = multiprocessing.Manager()
            self.users = self.manager.dict()
            self.lock = multiprocessing.Lock()  # saves inter process communication vs. self.manager.Lock()
        else:
            self.manager = None
            self.users = {}
            self.lock = threading.Lock()

    def login(self, user_id):
        """
        get a new login token
        """
        token = UserToken.get(user_id)
        with self.lock:
            self.users[user_id] = token
        return token

    def validate(self, token):
        """
        return the user_id if the token is valid or None otherwise
        """
        user_id = UserToken.validate(token, timeout=SESSION_KEY_EXPIRATION)
        if user_id:
            if self.users[user_id] == token:
                return user_id
        logger.debug('Users: %s \nUser_id: %s \nUser_token: %s', self.users, user_id, token)
        return None


class Levels(object):
    """
    Manage shared levels object
    When created, this will spawn a 'manager' process if forked=True
    """
    def __init__(self, forked=True):
        """
        :param forked: boolean, if True a sync manager server is created to share data
            otherwise the data will be shared only between threads.
        """
        if forked:
            self.manager = multiprocessing.Manager()
            self.levels = self.manager.dict()  # dictionaries with the highest scores per level (key:user, value:score)
            # if more than one high score per user was allowed we could use heaps instead
            self.lock = multiprocessing.Lock()
        else:
            self.manager = None
            self.levels = {}
            self.lock = threading.Lock()

    def save_score(self, user, level, score):
        with self.lock:
            manager_level = self.levels.get(level, {})

            if user in manager_level:
                if manager_level[user] < score:
                    manager_level[user] = score

            else:
                manager_level[user] = score

                if len(manager_level) > NUM_TOP_SCORES:
                    user_to_remove = min(manager_level, key=lambda x: manager_level[x])
                    manager_level.pop(user_to_remove)

            # We need to re-assign the modified object to the container (remotely creating a new container does not work)
            # https://docs.python.org/2/library/multiprocessing.html#multiprocessing.managers.SyncManager.list
            self.levels[level] = manager_level

    def get_highest_scores(self, level):
        """
        Retrieves the high scores for a specific level. 
        The result is a comma separated list in descending score order. 
        Because of memory reasons no more than 15 scores are to be returned for each level. 
        
        If a user hasn't submitted a score for the level, no score is present for that user. 
        A request for a high score list of a level without any scores submitted shall be an empty string.
        """
        res = self.levels.get(level, {}).items()
        res.sort(key=lambda x: x[1], reverse=True)
        return res
